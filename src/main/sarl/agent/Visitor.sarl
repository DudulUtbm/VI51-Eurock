package ^agent

import Behaviour.KinematicSeekBehaviour
import Behaviour.KinematicWanderBehaviour
import Behaviour.SeekBehaviour
import Behaviour.WanderBehaviour
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import java.util.HashMap
import org.arakhne.afc.math.continous.object2d.Point2f
import vi51.util.ConstantContainer
import org.arakhne.afc.math.continous.object2d.Circle2f
import java.util.ArrayList
import vi51.environment.Perceivable
import org.arakhne.afc.math.continous.object2d.Vector2f
import vi51.util.Semantic
import vi51.util.Variation
import vi51.util.Actions

/**
 * @author Dudul
 *
 */
agent Visitor extends AbstractAnimat {

	uses  Lifecycle, DesireManager
	
	var seekBehaviour : SeekBehaviour
	var wanderBehaviour : WanderBehaviour
	var recommandation : String
	  
	on Initialize{
		super._handle_Initialize_0(occurrence)
		var desires = new VisitorDesire(ConstantContainer.BASIC_MUSIC_DESIRE,ConstantContainer.BASIC_THIRSTY,ConstantContainer.BASIC_HUNGRY,ConstantContainer.BASIC_PEE)
		setSkill(DesireManager,desires)
	}
		
	on Perception{
		
		var bestAction = chooseBestBasedOnAverageValue
		
		var body = occurrence.body
		var target : Point2f = null
		var targetType : Semantic = null
		var nearBodies = new ArrayList<Perceivable>
		var radius = new Circle2f(body.position,ConstantContainer.PRIVATE_RADIUS)
		
		if(occurrence.objects.size()>0){
			for (object : occurrence.objects){
				
				if((object.getType.equals(Semantic.Visitor) || object.getType.equals(Semantic.BodyGuard)) && radius.intersects(object.getBox))nearBodies.add(object)
				
				else if (bestAction.equals(Actions.ListenMusic) &&  object.getType.equals(Semantic.Scene)){
					target = object.getPosition()
					targetType = Semantic.Scene
				}
				else if (bestAction.equals(Actions.Pee) && object.getType.equals(Semantic.Toilet)){
					target = object.getPosition()
					targetType=Semantic.Toilet
				}
				else if (bestAction.equals(Actions.Drink) && object.getType.equals(Semantic.DrinkStand)){
					target = object.getPosition()
					targetType=Semantic.DrinkStand
				}
				else if (bestAction.equals(Actions.Eat) && object.getType.equals(Semantic.EatStand)){
					target = object.getPosition()
					targetType=Semantic.EatStand
				}
//				else if (object.getType.equals(Semantic.Gate)){
//					target = object.getPosition()
//					targetType=Semantic.Gate
//				}
				// Groupe favori
				else if (object.getName.equals(this.recommandation)){
					target = object.getPosition()
					bestAction = Actions.ListenMusic
					targetType = Semantic.Scene
				}
			}
			if(target!=null){
				this.seekBehaviour = new KinematicSeekBehaviour
				applyVariation(bestAction)
				var o = this.seekBehaviour.runSeek(
					body.position,
					body.currentLinearMotion.length,
					body.maxLinearSpeed,
					target
				)
				o.setLinear(PrivateZone(body.position,nearBodies,body.currentLinearMotion,targetType))
				o.emitInfluence(occurrence.time)
			}else{
				this.wanderBehaviour = new KinematicWanderBehaviour
				//position : Point2f, orientation : Vector2f, linearSpeed : float, maxLinear : float, angularSpeed : float, maxAngular : float
				var o = this.wanderBehaviour.runWander(
				body.position,
				body.currentLinearMotion,
				body.currentLinearMotion.length,
				body.maxLinearSpeed,
				body.currentAngularSpeed,
				body.maxAngularSpeed
				)
				o.emitInfluence(occurrence.time)
			}
		}else{
			this.wanderBehaviour = new KinematicWanderBehaviour
			//position : Point2f, orientation : Vector2f, linearSpeed : float, maxLinear : float, angularSpeed : float, maxAngular : float
			var o = this.wanderBehaviour.runWander(
			body.position,
			body.currentLinearMotion,
			body.currentLinearMotion.length,
			body.maxLinearSpeed,
			body.currentAngularSpeed,
			body.maxAngularSpeed
			)
			o.emitInfluence(occurrence.time)
		}
		
	}

}